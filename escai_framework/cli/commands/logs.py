"""
Log management and analysis commands for ESCAI CLI.

This module provides commands for managing, analyzing, and troubleshooting
log files generated by the CLI system.
"""

import click
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress

from ..utils.console import get_console
from ..utils.logging_system import get_logger, set_debug_mode
from ..utils.debug_mode import enable_debug, disable_debug, is_debug_enabled
from ..utils.error_tracker import get_error_stats, generate_error_report
from ..utils.log_analyzer import analyze_cli_logs
from ..utils.log_management import (
    get_log_manager, perform_log_maintenance, 
    get_log_storage_stats, generate_log_storage_report
)
from ..utils.error_decorators import handle_cli_errors, create_command_context
from ..utils.error_handling import CLIErrorHandler

console = get_console()
logger = get_logger("cli.logs")
error_handler = CLIErrorHandler(console=console)


@click.group(name='logs')
def logs_group():
    """Log management and analysis commands."""
    pass


@logs_group.command()
@click.option('--days', '-d', default=7, help='Number of days to analyze (default: 7)')
@click.option('--level', '-l', type=click.Choice(['TRACE', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']),
              help='Filter by log level')
@click.option('--output', '-o', type=click.Choice(['console', 'json', 'csv']), default='console',
              help='Output format (default: console)')
@handle_cli_errors(error_handler=error_handler, context_factory=create_command_context("logs.analyze"))
def analyze(days: int, level: Optional[str], output: str):
    """
    Analyze log files for patterns, errors, and performance issues.
    
    This command performs comprehensive analysis of CLI log files to identify:
    - Error patterns and frequencies
    - Performance bottlenecks
    - Usage trends
    - System health indicators
    
    Examples:
        escai logs analyze --days 7
        escai logs analyze --level ERROR --days 30
        escai logs analyze --output json > analysis.json
    """
    logger.user_action(f"Log analysis requested for {days} days", extra={
        "days": days, "level": level, "output": output
    })
    
    with console.status("[cyan]Analyzing log files...[/cyan]"):
        try:
            # Determine date range
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            # Perform analysis
            log_dir = Path.home() / ".escai" / "logs"
            analysis = analyze_cli_logs(log_dir, start_date, end_date, level)
            
            if output == 'console':
                _display_analysis_console(analysis, days)
            elif output == 'json':
                import json
                click.echo(json.dumps(analysis, indent=2, default=str))
            elif output == 'csv':
                _export_analysis_csv(analysis)
            
            logger.info(f"Log analysis completed for {days} days")
            
        except Exception as e:
            logger.error(f"Log analysis failed: {e}")
            console.print(f"[red]Error analyzing logs: {e}[/red]")
            raise


@logs_group.command()
@click.option('--days', '-d', default=7, help='Number of days to include in report (default: 7)')
@handle_cli_errors(error_handler=error_handler, context_factory=create_command_context("logs.errors"))
def errors(days: int):
    """
    Generate comprehensive error report from tracked errors.
    
    Shows error statistics, trends, and troubleshooting recommendations
    based on errors tracked by the CLI system.
    
    Examples:
        escai logs errors
        escai logs errors --days 30
    """
    logger.user_action(f"Error report requested for {days} days", extra={"days": days})
    
    try:
        # Generate error report
        generate_error_report(days)
        
        # Show additional error statistics
        stats = get_error_stats(days)
        
        if stats['total_errors'] == 0:
            console.print(f"[green]✅ No errors found in the last {days} days![/green]")
        else:
            # Show recommendations
            if stats.get('most_frequent'):
                console.print("\n[bold yellow]💡 Troubleshooting Recommendations:[/bold yellow]")
                
                for i, error in enumerate(stats['most_frequent'][:3], 1):
                    console.print(f"{i}. Address '{error['error_type']}' errors (occurred {error['count']} times)")
        
        logger.info(f"Error report generated for {days} days")
        
    except Exception as e:
        logger.error(f"Error report generation failed: {e}")
        console.print(f"[red]Error generating report: {e}[/red]")
        raise


@logs_group.command()
@click.option('--cleanup', is_flag=True, help='Perform cleanup operations')
@click.option('--rotate', is_flag=True, help='Rotate large log files')
@click.option('--compress', is_flag=True, help='Compress old log files')
@click.option('--archive', is_flag=True, help='Archive old log files')
@handle_cli_errors(error_handler=error_handler, context_factory=create_command_context("logs.maintenance"))
def maintenance(cleanup: bool, rotate: bool, compress: bool, archive: bool):
    """
    Perform log file maintenance operations.
    
    Includes rotation, compression, archival, and cleanup of log files
    to manage disk space and maintain system performance.
    
    Examples:
        escai logs maintenance --cleanup
        escai logs maintenance --rotate --compress
        escai logs maintenance --archive
    """
    logger.user_action("Log maintenance requested", extra={
        "cleanup": cleanup, "rotate": rotate, "compress": compress, "archive": archive
    })
    
    if not any([cleanup, rotate, compress, archive]):
        # If no specific operations requested, perform full maintenance
        cleanup = rotate = compress = archive = True
    
    with Progress() as progress:
        task = progress.add_task("[cyan]Performing log maintenance...", total=100)
        
        try:
            results = perform_log_maintenance()
            progress.update(task, completed=100)
            
            # Display results
            results_table = Table(title="Maintenance Results")
            results_table.add_column("Operation", style="cyan")
            results_table.add_column("Count", style="yellow")
            
            results_table.add_row("Files Rotated", str(len(results.get('rotated_files', []))))
            results_table.add_row("Files Compressed", str(len(results.get('compressed_files', []))))
            results_table.add_row("Files Archived", str(len(results.get('archived_files', []))))
            results_table.add_row("Files Deleted", str(len(results.get('deleted_files', []))))
            results_table.add_row("Maintenance Time", f"{results.get('maintenance_time', 0):.2f}s")
            
            console.print(Panel(results_table, title="[bold green]Maintenance Complete[/bold green]"))
            
            if results.get('errors'):
                console.print("\n[yellow]Warnings:[/yellow]")
                for error in results['errors']:
                    console.print(f"  • {error}")
            
            logger.info(f"Log maintenance completed in {results.get('maintenance_time', 0):.2f}s")
            
        except Exception as e:
            logger.error(f"Log maintenance failed: {e}")
            console.print(f"[red]Error during maintenance: {e}[/red]")
            raise


@logs_group.command()
@handle_cli_errors(error_handler=error_handler, context_factory=create_command_context("logs.stats"))
def stats():
    """
    Display log file storage statistics.
    
    Shows information about log file sizes, counts, and storage usage
    to help monitor disk space usage.
    
    Examples:
        escai logs stats
    """
    logger.user_action("Log statistics requested")
    
    try:
        # Generate storage report
        generate_log_storage_report()
        
        logger.info("Log statistics displayed")
        
    except Exception as e:
        logger.error(f"Failed to generate log statistics: {e}")
        console.print(f"[red]Error getting statistics: {e}[/red]")
        raise


@logs_group.command()
@click.option('--enable', is_flag=True, help='Enable debug mode')
@click.option('--disable', is_flag=True, help='Disable debug mode')
@click.option('--verbose', is_flag=True, help='Enable verbose logging')
@click.option('--interactive', is_flag=True, help='Enable interactive debugging')
@handle_cli_errors(error_handler=error_handler, context_factory=create_command_context("logs.debug"))
def debug(enable: bool, disable: bool, verbose: bool, interactive: bool):
    """
    Control debug mode and logging levels.
    
    Enables or disables debug mode with various options for enhanced
    troubleshooting and development.
    
    Examples:
        escai logs debug --enable --verbose
        escai logs debug --enable --interactive
        escai logs debug --disable
    """
    if enable and disable:
        console.print("[red]Error: Cannot enable and disable debug mode simultaneously[/red]")
        return
    
    if enable:
        enable_debug(verbose=verbose, interactive=interactive)
        set_debug_mode(True)
        
        console.print("[green]✅ Debug mode enabled[/green]")
        if verbose:
            console.print("[dim]  • Verbose logging enabled[/dim]")
        if interactive:
            console.print("[dim]  • Interactive debugging enabled[/dim]")
        
        logger.user_action("Debug mode enabled", extra={
            "verbose": verbose, "interactive": interactive
        })
        
    elif disable:
        disable_debug()
        set_debug_mode(False)
        
        console.print("[yellow]Debug mode disabled[/yellow]")
        logger.user_action("Debug mode disabled")
        
    else:
        # Show current status
        if is_debug_enabled():
            console.print("[green]🐛 Debug mode is currently [bold]enabled[/bold][/green]")
        else:
            console.print("[dim]Debug mode is currently [bold]disabled[/bold][/dim]")


def _display_analysis_console(analysis: dict, days: int):
    """Display analysis results in console format."""
    summary = analysis.get('summary', {})
    
    # Summary panel
    summary_text = f"""
[bold]Analysis Period:[/bold] Last {days} days
[bold]Total Log Entries:[/bold] {summary.get('total_entries', 0):,}
[bold]Health Score:[/bold] {summary.get('health_score', 0):.1f}/100
[bold]Error Count:[/bold] {summary.get('total_errors', 0)}
[bold]Pattern Count:[/bold] {summary.get('total_patterns', 0)}
"""
    
    console.print(Panel(summary_text.strip(), title="[bold blue]Analysis Summary[/bold blue]"))
    
    # Top patterns
    patterns = analysis.get('patterns', [])
    if patterns:
        pattern_table = Table(title="Top Log Patterns")
        pattern_table.add_column("Pattern", style="cyan")
        pattern_table.add_column("Count", style="yellow")
        pattern_table.add_column("Severity", style="red")
        
        for pattern in patterns[:5]:
            pattern_table.add_row(
                pattern.pattern,
                str(pattern.count),
                pattern.severity
            )
        
        console.print(pattern_table)
    
    # Recommendations
    recommendations = analysis.get('recommendations', [])
    if recommendations:
        rec_text = "\n".join(f"• {rec}" for rec in recommendations)
        console.print(Panel(rec_text, title="[bold yellow]Recommendations[/bold yellow]"))


def _export_analysis_csv(analysis: dict):
    """Export analysis results to CSV format."""
    import csv
    import io
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Write summary
    writer.writerow(['Summary'])
    summary = analysis.get('summary', {})
    for key, value in summary.items():
        writer.writerow([key, value])
    
    writer.writerow([])  # Empty row
    
    # Write patterns
    writer.writerow(['Patterns'])
    writer.writerow(['Pattern', 'Count', 'Severity', 'First Occurrence', 'Last Occurrence'])
    
    for pattern in analysis.get('patterns', []):
        writer.writerow([
            pattern.pattern,
            pattern.count,
            pattern.severity,
            pattern.first_occurrence,
            pattern.last_occurrence
        ])
    
    click.echo(output.getvalue())